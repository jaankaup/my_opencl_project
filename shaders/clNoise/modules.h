Generator *Billow_Mod = new Generator("Billow");
Billow_Mod->setModuleSource(Billow_Src);
Billow_Mod->setAttribute(0, Attribute("frequency", 1.0f, 0.01f, 100.0f));
Billow_Mod->setAttribute(1, Attribute("lacunarity", 2.0f, 0.01f, 10.0f));
Billow_Mod->setAttribute(2, Attribute("octaveCount", 6, 1, 10));
Billow_Mod->setAttribute(3, Attribute("persistence", 0.5f, 0.01f, 10.0f));
Billow_Mod->setAttribute(4, Attribute("seed", 0, 0, 65535));
Billow_Mod->addDependency("GradientCoherentNoise3D");
Billow_Mod->addDependency("MakeInt32Range");
Billow_Mod->setOutputType(BaseModule::ContactInfo::FLOAT);
availableModules.insert(std::make_pair("Billow", Billow_Mod));
Filter *MIN_Mod = new Filter("MIN");
MIN_Mod->setModuleSource(MIN_Src);
MIN_Mod->setOutputType(BaseModule::ContactInfo::FLOAT);
MIN_Mod->addInput(BaseModule::ContactInfo("VALUE1", BaseModule::ContactInfo::FLOAT));
MIN_Mod->addInput(BaseModule::ContactInfo("VALUE2", BaseModule::ContactInfo::FLOAT));
availableModules.insert(std::make_pair("MIN", MIN_Mod));
Filter *MAX_Mod = new Filter("MAX");
MAX_Mod->setModuleSource(MAX_Src);
MAX_Mod->setOutputType(BaseModule::ContactInfo::FLOAT);
MAX_Mod->addInput(BaseModule::ContactInfo("VALUE1", BaseModule::ContactInfo::FLOAT));
MAX_Mod->addInput(BaseModule::ContactInfo("VALUE2", BaseModule::ContactInfo::FLOAT));
availableModules.insert(std::make_pair("MAX", MAX_Mod));
Filter *ABS_Mod = new Filter("ABS");
ABS_Mod->setModuleSource(ABS_Src);
ABS_Mod->setOutputType(BaseModule::ContactInfo::FLOAT);
ABS_Mod->addInput(BaseModule::ContactInfo("VALUE", BaseModule::ContactInfo::FLOAT));
availableModules.insert(std::make_pair("ABS", ABS_Mod));
Filter *CLAMP_Mod = new Filter("CLAMP");
CLAMP_Mod->setModuleSource(CLAMP_Src);
CLAMP_Mod->setAttribute(0, Attribute("MINVAL", -1.0f, -5.0f, 5.0f));
CLAMP_Mod->setAttribute(1, Attribute("MAXVAL", 1.0f, -5.0f, 5.0f));
CLAMP_Mod->addInput(BaseModule::ContactInfo("VALUE", BaseModule::ContactInfo::FLOAT));
CLAMP_Mod->setOutputType(BaseModule::ContactInfo::FLOAT);
availableModules.insert(std::make_pair("CLAMP", CLAMP_Mod));
Filter *MIX_Mod = new Filter("MIX");
MIX_Mod->setModuleSource(MIX_Src);
MIX_Mod->addInput(BaseModule::ContactInfo("X", BaseModule::ContactInfo::FLOAT));
MIX_Mod->addInput(BaseModule::ContactInfo("Y", BaseModule::ContactInfo::FLOAT));
MIX_Mod->addInput(BaseModule::ContactInfo("A", BaseModule::ContactInfo::FLOAT));
MIX_Mod->setOutputType(BaseModule::ContactInfo::FLOAT);
availableModules.insert(std::make_pair("MIX", MIX_Mod));
Filter *SMOOTHSTEP_Mod = new Filter("SMOOTHSTEP");
SMOOTHSTEP_Mod->setModuleSource(SMOOTHSTEP_Src);
SMOOTHSTEP_Mod->addInput(BaseModule::ContactInfo("EDGE0", BaseModule::ContactInfo::FLOAT));
SMOOTHSTEP_Mod->addInput(BaseModule::ContactInfo("EDGE1", BaseModule::ContactInfo::FLOAT));
SMOOTHSTEP_Mod->addInput(BaseModule::ContactInfo("X", BaseModule::ContactInfo::FLOAT));
SMOOTHSTEP_Mod->setOutputType(BaseModule::ContactInfo::FLOAT);
availableModules.insert(std::make_pair("SMOOTHSTEP", SMOOTHSTEP_Mod));
Generator *Checkerboard_Mod = new Generator("Checkerboard");
Checkerboard_Mod->setModuleSource(Checkerboard_Src);
Checkerboard_Mod->addDependency("MakeInt32Range");
Checkerboard_Mod->setOutputType(BaseModule::ContactInfo::FLOAT);
availableModules.insert(std::make_pair("Checkerboard", Checkerboard_Mod));
Generator *Const_Mod = new Generator("Const");
Const_Mod->setModuleSource(Const_Src);
Const_Mod->setAttribute(0, Attribute("value", 0.0f, -1.0f, 1.0f));
Const_Mod->setOutputType(BaseModule::ContactInfo::FLOAT);
availableModules.insert(std::make_pair("Const", Const_Mod));
Generator *Cylinders_Mod = new Generator("Cylinders");
Cylinders_Mod->setModuleSource(Cylinders_Src);
Cylinders_Mod->setAttribute(0, Attribute("frequency", 1.0f, 0.01f, 100.0f));
Cylinders_Mod->setOutputType(BaseModule::ContactInfo::FLOAT);
availableModules.insert(std::make_pair("Cylinders", Cylinders_Mod));
Filter *gradient_Mod = new Filter("gradient");
gradient_Mod->setModuleSource(gradient_Src);
gradient_Mod->setAttribute(0, GradientAttribute("gradientPoints"));
gradient_Mod->setOutputType(BaseModule::ContactInfo::RGBA);
gradient_Mod->addInput(BaseModule::ContactInfo("NOISE_VALUE", BaseModule::ContactInfo::FLOAT));
availableModules.insert(std::make_pair("gradient", gradient_Mod));
Function *GradientCoherentNoise3D_Mod = new Function("GradientCoherentNoise3D");
GradientCoherentNoise3D_Mod->setModuleSource(GradientCoherentNoise3D_Src);
GradientCoherentNoise3D_Mod->addDependency("GradientNoise3D");
GradientCoherentNoise3D_Mod->addDependency("SCurve5");
GradientCoherentNoise3D_Mod->setProto("float GradientCoherentNoise3D (float x, float y, float z, int seed) \n");
availableModules.insert(std::make_pair("GradientCoherentNoise3D", GradientCoherentNoise3D_Mod));
Function *GradientNoise3D_Mod = new Function("GradientNoise3D");
GradientNoise3D_Mod->setModuleSource(GradientNoise3D_Src);
GradientNoise3D_Mod->setProto("float GradientNoise3D (float fx, float fy, float fz, int ix, int iy, int iz, int seed) \n");
availableModules.insert(std::make_pair("GradientNoise3D", GradientNoise3D_Mod));
Filter *grayscale_Mod = new Filter("grayscale");
grayscale_Mod->setModuleSource(grayscale_Src);
grayscale_Mod->setOutputType(BaseModule::ContactInfo::RGBA);
grayscale_Mod->addInput(BaseModule::ContactInfo("NOISE_VALUE", BaseModule::ContactInfo::FLOAT));
availableModules.insert(std::make_pair("grayscale", grayscale_Mod));
Function *MakeInt32Range_Mod = new Function("MakeInt32Range");
MakeInt32Range_Mod->setModuleSource(MakeInt32Range_Src);
MakeInt32Range_Mod->setProto("float MakeInt32Range (float n) \n");
availableModules.insert(std::make_pair("MakeInt32Range", MakeInt32Range_Mod));
Generator *Perlin_Mod = new Generator("Perlin");
Perlin_Mod->setModuleSource(Perlin_Src);
Perlin_Mod->setAttribute(0, Attribute("frequency", 1.0f, 0.01f, 100.0f));
Perlin_Mod->setAttribute(1, Attribute("lacunarity", 2.0f, 0.01f, 10.0f));
Perlin_Mod->setAttribute(2, Attribute("octaveCount", 6, 1, 10));
Perlin_Mod->setAttribute(3, Attribute("persistence", 0.5f, 0.01f, 10.0f));
Perlin_Mod->setAttribute(4, Attribute("seed", 0, 0, 65535));
Perlin_Mod->addDependency("GradientCoherentNoise3D");
Perlin_Mod->addDependency("MakeInt32Range");
Perlin_Mod->setOutputType(BaseModule::ContactInfo::FLOAT);
availableModules.insert(std::make_pair("Perlin", Perlin_Mod));
Output *PlaneMap_Mod = new Output("PlaneMap");
PlaneMap_Mod->setModuleSource(PlaneMap_Src);
PlaneMap_Mod->setOutputType(BaseModule::ContactInfo::RGBA);
PlaneMap_Mod->addInput(BaseModule::ContactInfo("COLOR", BaseModule::ContactInfo::RGBA));
availableModules.insert(std::make_pair("PlaneMap", PlaneMap_Mod));
Generator *RidgedMulti_Mod = new Generator("RidgedMulti");
RidgedMulti_Mod->setModuleSource(RidgedMulti_Src);
RidgedMulti_Mod->setAttribute(0, Attribute("frequency", 1.0f, 0.01f, 100.0f));
RidgedMulti_Mod->setAttribute(1, Attribute("lacunarity", 2.0f, 0.01f, 10.0f));
RidgedMulti_Mod->setAttribute(2, Attribute("octaveCount", 6, 1, 10));
RidgedMulti_Mod->setAttribute(3, Attribute("persistence", 0.5f, 0.01f, 10.0f));
RidgedMulti_Mod->setAttribute(4, Attribute("seed", 0, 0, 65535));
RidgedMulti_Mod->setAttribute(5, Attribute("offset", 1.0f, 0.1f, 2.0f));
RidgedMulti_Mod->setAttribute(6, Attribute("gain", 2.0f, 0.1f, 4.0f));
RidgedMulti_Mod->setAttribute(7, Attribute("spectralWeightExponent", 1.0f, 0.1f, 5.0f));
RidgedMulti_Mod->addDependency("GradientCoherentNoise3D");
RidgedMulti_Mod->addDependency("MakeInt32Range");
RidgedMulti_Mod->setOutputType(BaseModule::ContactInfo::FLOAT);
availableModules.insert(std::make_pair("RidgedMulti", RidgedMulti_Mod));
Function *SCurve5_Mod = new Function("SCurve5");
SCurve5_Mod->setModuleSource(SCurve5_Src);
SCurve5_Mod->setProto("float SCurve5 (float a) \n");
availableModules.insert(std::make_pair("SCurve5", SCurve5_Mod));
Filter *turbulence_Mod = new Filter("turbulence");
turbulence_Mod->setModuleSource(turbulence_Src);
turbulence_Mod->setOutputType(BaseModule::ContactInfo::FLOAT);
turbulence_Mod->setAttribute(0, Attribute("power", 1.0f, 0.01f, 10.0f));
turbulence_Mod->addInput(BaseModule::ContactInfo("INPUT", BaseModule::ContactInfo::FLOAT));
turbulence_Mod->addInput(BaseModule::ContactInfo("XDISTORT", BaseModule::ContactInfo::FLOAT));
turbulence_Mod->addInput(BaseModule::ContactInfo("YDISTORT", BaseModule::ContactInfo::FLOAT));
availableModules.insert(std::make_pair("turbulence", turbulence_Mod));
Generator *Voronoi_Mod = new Generator("Voronoi");
Voronoi_Mod->setModuleSource(Voronoi_Src);
Voronoi_Mod->setAttribute(0, Attribute("frequency", 1.0f, 0.01f, 100.0f));
Voronoi_Mod->setAttribute(1, Attribute("displacement", 1.0f, 0.01f, 100.0f));
Voronoi_Mod->setAttribute(2, Attribute("seed", 0, 0, 65535));
Voronoi_Mod->setAttribute(3, Attribute("enableDistance", 0, 0, 1));
Voronoi_Mod->addDependency("GradientNoise3D");
Voronoi_Mod->addDependency("MakeInt32Range");
Voronoi_Mod->setOutputType(BaseModule::ContactInfo::FLOAT);
availableModules.insert(std::make_pair("Voronoi", Voronoi_Mod));
