const char *GradientCoherentNoise3D_Src = "\n"
"float GradientCoherentNoise3D (float x, float y, float z, int seed)\n"
"{\n"
"  // Create a unit-length cube aligned along an integer boundary.  This cube\n"
"  // surrounds the input point.\n"
"  int x0 = (x > 0.0f? (int)x: (int)x - 1);\n"
"  int x1 = x0 + 1;\n"
"  int y0 = (y > 0.0f? (int)y: (int)y - 1);\n"
"  int y1 = y0 + 1;\n"
"  int z0 = (z > 0.0f? (int)z: (int)z - 1);\n"
"  int z1 = z0 + 1;\n"
"\n"
"  // Map the difference between the coordinates of the input value and the\n"
"  // coordinates of the cube's outer-lower-left vertex onto an S-curve.\n"
"  float xs = 0.0f, ys = 0.0f, zs = 0.0f;\n"
"  xs = SCurve5 (x - (float)x0);\n"
"  ys = SCurve5 (y - (float)y0);\n"
"  zs = SCurve5 (z - (float)z0);\n"
"\n"
" // Now calculate the noise values at each vertex of the cube.  To generate\n"
"  // the coherent-noise value at the input point, interpolate these eight\n"
"  // noise values using the S-curve value as the interpolant (trilinear\n"
"  // interpolation.)\n"
"  float n0, n1, ix0, ix1, iy0, iy1;\n"
"  n0   = GradientNoise3D (x, y, z, x0, y0, z0, seed);\n"
"  n1   = GradientNoise3D (x, y, z, x1, y0, z0, seed);\n"
"  ix0  = mix (n0, n1, xs);\n"
"  n0   = GradientNoise3D (x, y, z, x0, y1, z0, seed);\n"
"  n1   = GradientNoise3D (x, y, z, x1, y1, z0, seed);\n"
"  ix1  = mix (n0, n1, xs);\n"
"  iy0  = mix (ix0, ix1, ys);\n"
"  n0   = GradientNoise3D (x, y, z, x0, y0, z1, seed);\n"
"  n1   = GradientNoise3D (x, y, z, x1, y0, z1, seed);\n"
"  ix0  = mix (n0, n1, xs);\n"
"  n0   = GradientNoise3D (x, y, z, x0, y1, z1, seed);\n"
"  n1   = GradientNoise3D (x, y, z, x1, y1, z1, seed);\n"
"  ix1  = mix (n0, n1, xs);\n"
"  iy1  = mix (ix0, ix1, ys);\n"
"\n"
"  return mix (iy0, iy1, zs);\n"
"}\n"
"\n"
;